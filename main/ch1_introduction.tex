%!TEX root = ../phd.tex

\chapter{Introduction}

\section{Background}
\label{sec:background}
\todo{remove tool}
In this section we provide background information necessary for understanding \yy's
implementation in Scala. We briefly explain the core concepts of Lightweight Modular Staging
\cite{rompf_lightweight_2012,rompf_optimizing_2013} and Scala Macros
\cite{burmako_scala_2013}. Throughout the paper we assume familiarity with
the basics of the Scala Programming Language~\cite{odersky_scala_2004}.

\subsection{Deep Embedding of DSLs with LMS}
\label{subsec:deep-embedding}

% LMS
Lightweight Modular Staging (LMS) is a
staging~\cite{taha_multi-stage_1997} framework and an embedded
compiler for developing deeply embedded DSLs.  LMS provides a library
of reusable language components organized as \emph{traits} (Scala's
first-class modules).  An \edsl developer selects traits containing
the desired language features, combines them through \emph{mix-in}
composition~\cite{odersky_scalable_2005} and adds DSL-specific
functionality to the resulting \edsl trait.  \edsl programs then
extend this trait, inheriting the selected LMS and \edsl language
constructs. \figref{lst:lms} illustrates this principle.  The trait
\code{VectorDSL} defines a simplified \edsl for creating and
manipulating vectors over some numeric type \code{T}.  Two LMS traits
are mixed into the \code{VectorDSL} trait: the \code{Base} trait
introduces core LMS constructs %(e.g., abstract type \code{Rep})
and the \code{NumericOps} trait introduces the \code{Numeric} type
class and the corresponding support for numeric operations.  The
bottom of the figure shows an example usage of the \edsl. The constant
literals in the program are lifted to the IR through \emph{implicit
  conversions} introduced by
\code{NumericOps}~\cite{oliveira_type_2010}.

\begin{figure}
\begin{listingtiny}
// The EDSL declaration
trait VectorDSL extends NumericOps with Base {
  object Vector {
    def fill[T:Numeric]
      (v: Rep[T], size: Rep[Int]): Rep[Vector[T]] =
      vector_fill(v, size)
  }

  implicit class VectorOps[T:Numeric]
    (v: Rep[Vector[T]]) {
    def +(that: Rep[Vector[T]]): Rep[Vector[T]] =
      vector_+(v, that)
  }
  // Operations vector_fill and vector_+ are elided
}

new VectorDSL { // EDSL program
  Vector.fill(1,3) + Vector.fill(2,3)
} // returns a regular Scala Vector(3,6)
\end{listingtiny}
\caption{\label{lst:lms} Minimal \edsl for vector manipulation.}
\end{figure}

% Rep types
All types in the \code{VectorDSL} interface are instances of the
parametric type \code{Rep[_]}.  The \code{Rep[_]} type is an abstract
type member of the \code{Base} LMS trait and abstracts over the
concrete types of the IR nodes that represent DSL operations in the
deep embedding.  Its type parameter captures the type underlying the
IR: \edsl terms of type \code{Rep[T]} evaluate to host language terms
of type \code{T} during \edsl execution.

% Operations
Operations on \code{Rep[T]} terms are added by implicit conversions that are introduced in the \edsl scope. For example, the implicit class \code{VectorOps} introduces the \code{+} operation on every term of type \code{Rep[Vector[T]]}. In the example, the type class \code{Numeric} ensures that vectors contain only numerical values.

\todo{remove tool}
% Statement about successful use
LMS has been successfully used by in project Delite~\cite{brown_heterogeneous_2011,composition-ecoop2013} for building DSLs that support heterogeneous parallel computing. \edsls developed with Delite cover domains
such as machine learning, graph processing, data mining, etc. Due to its wide use and high performance we choose Delite as a back-end for \yy.


\subsection{Scala Macros}
\label{sec:scala-macros}

% What are scala macros and how are they defined.
Scala Macros~\cite{burmako_scala_2013} are a compile-time meta-programming
feature of Scala. Macros operate on Scala abstract syntax trees (ASTs): they
can construct new ASTs, or transform and analyze the existing Scala ASTs.
Macro programs can use common functionality of the Scala compiler like
error-reporting, type checking, transformations, traversals, and implicit
search.

\yy uses a particular flavor of Scala macros called \emph{def
  macros}, though we will often drop the prefix ``def'' for the
sake of brevity.  From a programmer's point of view, def macros
are invoked just like regular Scala methods.  However, macro
invocations are \emph{expanded} during compile time to produce new
ASTs.  Macro invocations are type checked both before and after
expansion to ensure that expansion preserves well-typedness.  Macros
have separated declarations and definitions: declarations are
represented to the user as regular methods while macro definitions
operate on Scala ASTs.  The arguments of macro method definitions are
the type-checked ASTs of the macro arguments.

\todo{remove tool}
%Users / Usage
For DSLs based on \yy we use a macro that accepts a single block of
code as its input. At compile time, this block is first type checked
against the interface of the direct embedding. Then, \yy applies the
generic transformation to translate the directly embedded AST to the
corresponding deeply embedded AST.  For example, given the following
DSL snippet, \yy produces the \code{VectorDSL} program in
\figref{lst:lms}:\vspace{3pt}
\begin{listingtiny}
  vectorDSL {
    Vector.fill(1,3) + Vector.fill(2,3)
  }
\end{listingtiny}

% TODO
% Distinguish method and functions
% Universal method
% Pattern matching
% Prefixes
